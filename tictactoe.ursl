bits 8
minheap 0
minstack 15

.top_of_board [
    "    1   2   3\n"
    "  +---+---+---+"
    0
]

// question marks indicate variable data. the offsets into the string are hardcoded
.one_row [
    "? | ? | ? | ? |\n"
    "  +---+---+---+"
    0
]

.state [
    [ ' '   ' '   ' ' ]
    [ ' '   ' '   ' ' ]
    [ ' '   ' '   ' ' ]
]

.winner [ "? wins!" 0 ]
.draw [ "It's a draw!" 0 ]
.bad_input [ "Bad input (halting)" 0 ]
.occupied_square [ "That cell is occupied" 0 ]
.computer_no_move [ "lol u win cuz the\ncomputer fucking died" 0 ]

// pre-computed values; the computer will try to move to the right, then the left, then top, then under (without wrapping)
// after that, it should have placed for sure
// 9 is terminator because it is invalid data
.moves0 [ 1 2 9 ]
.moves1 [ 2 0 4 9 ]
.moves2 [ 1 5 9 ]
.moves3 [ 4 0 6 9 ]
.moves4 [ 5 3 1 7 9 ]
.moves5 [ 4 2 8 9 ]
.moves6 [ 7 3 9 ]
.moves7 [ 8 6 4 9 ]
.moves8 [ 7 5 9 ]
.moves [
    .moves0 .moves1 .moves2
    .moves3 .moves4 .moves5
    .moves6 .moves7 .moves8
]

.triples [
    [ 0 1 2 ]
    [ 3 4 5 ]
    [ 6 7 8 ]
    [ 0 3 6 ]
    [ 1 4 7 ]
    [ 2 5 8 ]
    [ 0 4 8 ]
    [ 2 4 6 ]
]

// i am allowed to use the internal syntax. i need it for this, because of size limitations.
__binary__ add.load -> LLOD;
inst add.store <&base> <&offset> <&value> {
    LSTR &base &offset &value;
}

func $main {
    call $print_board
    
    // const 0
    // label :test_loop
    //     dup
    //     const 9
    //     gte branch :test_loop_end
    // const .poses over
    // add.load
    // over const '0' add
    // store
    // inc
    // jump :test_loop
    // height 1
    // label :test_loop_end
    // pop

    label :game_loop

        call $input
        dup
        const .state
            over over
            add.load
            const ' '
            eq branch :valid_input
        pop pop pop
        call $state_update
        const .occupied_square
        call $print_string
        jump :game_loop

        height 3
        label :valid_input
        const 'X'
        add.store
        call $state_update

        call $dumbass_ai
        call $state_update
    
    jump :game_loop
}

func $state_update {
    call $print_board

    const 0
    label :check_win_loop
        dup
        const 24
        gte branch :exit_check_win

        dup
        const .triples
        add.load
        const .state
        add.load

        const ' '
        over
        eq branch :not_matching

        over const 1
        add
        const .triples
        add.load
        const .state
        add.load
        over
        ne branch :not_matching

        over const 2
        add
        const .triples
        add.load
        const .state
        add.load
        over
        ne branch :not_matching

        const .winner
        swap store

        const .winner
        call $print_string
        halt

    height 2
    label :not_matching
    pop
    const 3 add
    jump :check_win_loop

    height 1
    label :exit_check_win
    pop

    const 0
    label :check_draw_loop
        dup
        const 8
        gte branch :its_a_draw

        const .state
        over
        add.load
        const ' '
        eq branch :not_a_draw

    inc
    jump :check_draw_loop

    height 1
    label :its_a_draw
    pop
    const .draw
    call $print_string
    halt

    height 1
    label :not_a_draw
    pop
}

func $dumbass_ai 1 -> 0 {
    get 0
    const .moves
        add.load
        const 0
        label :try_moves
            over over
            add.load

            dup const 9
            eq branch :died_try_moves

            const .state
            over over add.load const ' '
            eq branch :end_try_moves
            pop pop
        inc
        jump :try_moves

        height 3
        label :died_try_moves
            pop pop pop
            const .computer_no_move
            call $print_string
            halt

        height 4
        label :end_try_moves
            const 'O'
            add.store
            pop pop
}

func $random_ai 1 -> 0 {
    label :rng_loop

    in %RNG
    const 9
    mod
        const .state
        over
        add.load
        const ' '
        ne branch :bad_rng
    const .state
    const 'O'
    add.store
    ret

    height 1
    label :bad_rng
    pop
    jump :rng_loop
}

func $input 0 -> 1 {
    in %TEXT
    dup const 'A'
    over const 'C'
    gt branch :bad3
    lt branch :bad1

    const 'A' sub
    const 3 mult

    height 1

    in %TEXT
    dup const '1'
    over const '3'
    gt branch :bad4
    lt branch :bad2

    const '1' sub
    add

    in %TEXT
    const '\n'
    ne branch :bad1

    ret

    height 4
    label :bad4
    pop
    label :bad3
    pop
    label :bad2
    pop
    label :bad1
    pop

    const .bad_input
    call $print_string
    halt
}

func $print_board {

    // clear screen
    const 0x1B
    out %TEXT
    const '['
    out %TEXT
    const '2'
    out %TEXT
    const 'J'
    out %TEXT

    const .top_of_board
    call $print_string

    const 0
    const 'A'
    label :loop_rows
        dup const 'C'
        gt branch :end_loop_rows

        const .one_row over const 0 swap
        add.store

        over const .one_row swap const 4 swap
            const .state swap // const 0 add
            add.load
        add.store

        over const .one_row swap const 8 swap
            const .state swap const 1 add
            add.load
        add.store

        over const .one_row swap const 12 swap
            const .state swap const 2 add
            add.load
        add.store

        const .one_row
        call $print_string

    swap const 3 add
    swap inc
    jump :loop_rows

    height 2
    label :end_loop_rows
    pop pop
}

func $print_string 1 -> 0 {
    get 0

    label :loop
        dup
        load
            dup
            const 0
            eq branch :exit
        out %TEXT
    inc
    jump :loop

    height 2
    label :exit
    pop pop
    const '\n'
    out %TEXT
}